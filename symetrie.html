<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Math CE2 – Reproduction sur quadrillage</title>

  <!-- Google Analytics (GA4) : remplace l'ID -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-XXXXXXXXXX"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-XXXXXXXXXX');
  </script>

  <style>
    * { box-sizing: border-box; font-family: system-ui, -apple-system, Segoe UI, sans-serif; }
    body { margin:0; background: radial-gradient(circle at top, #e0f2fe, #eff6ff); padding: 18px; }
    .app { max-width: 1100px; margin: 0 auto; background: #fff; border-radius: 18px; padding: 18px 18px 10px; box-shadow: 0 20px 40px rgba(15,23,42,.12); }
    header { display:flex; gap:12px; align-items:flex-start; justify-content:space-between; flex-wrap: wrap; }
    h1 { margin:0; font-size: 1.6rem; color:#0f172a; }
    .sub { margin:4px 0 0; color:#64748b; font-size:.95rem; }
    .pill { display:inline-block; padding:4px 10px; border-radius: 999px; background:#eff6ff; border:1px solid #bfdbfe; color:#1d4ed8; font-size:.85rem; text-decoration:none; }
    .toolbar { display:flex; flex-wrap: wrap; gap:10px; margin: 14px 0 10px; align-items:center; }
    select, button { border-radius:999px; border:1px solid #e2e8f0; padding:10px 14px; font-weight:600; background:#fff; cursor:pointer; }
    button.primary { background:#3b82f6; color:#fff; border:none; }
    button.dark { background:#0f172a; color:#fff; border:none; }
    button:disabled { opacity:.5; cursor:not-allowed; }
    .note { color:#64748b; font-size:.9rem; margin: 8px 0 14px; }
    .grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); gap:12px; }
    .card { border:1px solid #e2e8f0; background:#f8fafc; border-radius:14px; padding:12px; }
    .card h3 { margin:0 0 6px; font-size:1rem; color:#0f172a; }
    .pair { display:grid; grid-template-columns: 1fr 1fr; gap:10px; align-items:start; }
    .canvasWrap { background:#fff; border:1px solid #e2e8f0; border-radius:12px; padding:8px; }
    canvas { width:100%; height:auto; display:block; }
    .legend { display:flex; gap:8px; align-items:center; justify-content:space-between; margin-top:8px; color:#475569; font-size:.85rem; }
    .tag { display:inline-block; padding:2px 8px; border-radius:999px; background:#e0f2fe; color:#0369a1; }
    .hidden { display:none; }

    /* Impression / PDF */
    @media print {
      body { background:#fff; padding:0; }
      .app { box-shadow:none; border-radius:0; padding:0; }
      header, .toolbar, .note, .screenOnly { display:none !important; }
      .printTitle { display:block !important; padding:14px 0 8px; }
      .card { break-inside: avoid; page-break-inside: avoid; }
      .pageBreak { page-break-before: always; break-before: page; }
      .grid { grid-template-columns: 1fr 1fr; gap:10px; }
    }
    .printTitle { display:none; }
  </style>
</head>

<body>
  <main class="app">
    <header>
      <div>
        <h1>Reproduction sur quadrillage</h1>
        <p class="sub">Observe le modèle, repère les sommets (cases à droite/gauche – haut/bas), puis reproduis la figure.</p>
      </div>
      <a class="pill" href="index.html">← Retour menu</a>
    </header>

    <div class="toolbar screenOnly">
      <label>
        Niveau :
        <select id="level">
          <option value="1">Niveau 1 — facile</option>
          <option value="2" selected>Niveau 2 — moyen (comme la fiche)</option>
          <option value="3">Niveau 3 — reproduction + symétrie</option>
        </select>
      </label>

      <label>
        Exercices :
        <select id="count">
          <option value="4">4</option>
          <option value="6" selected>6</option>
          <option value="8">8</option>
        </select>
      </label>

      <button class="primary" id="btnNew">Nouveaux exercices</button>
      <button class="dark" id="btnCorr">Afficher / cacher correction</button>
      <button id="btnPrint">Imprimer / PDF</button>
    </div>

    <p class="note screenOnly">
      Astuce : commence par placer les <strong>sommets</strong>. Pour tracer un côté, compte les cases <strong>horizontalement</strong> puis <strong>verticalement</strong>.
    </p>

    <div class="printTitle">
      <h2 style="margin:0;">Math CE2 — Reproduction sur quadrillage</h2>
      <p style="margin:6px 0 0; color:#334155;">Nom : ____________  Date : ____ / ____ / ______</p>
    </div>

    <section id="exercises" class="grid"></section>

    <div class="pageBreak"></div>

    <div class="printTitle">
      <h2 style="margin:0;">Correction — Reproduction sur quadrillage</h2>
    </div>

    <section id="corrections" class="grid"></section>
  </main>

<script>
  // --------- utils ----------
  function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

  // grille
  const cells = 14;              // 14x14 cases
  const cellSize = 20;           // px
  const pad = 10;                // marge
  const W = pad*2 + cells*cellSize;
  const H = pad*2 + cells*cellSize;

  function drawGrid(ctx) {
    ctx.clearRect(0,0,W,H);
    ctx.beginPath();
    for (let i=0; i<=cells; i++){
      ctx.moveTo(pad + i*cellSize, pad);
      ctx.lineTo(pad + i*cellSize, pad + cells*cellSize);
      ctx.moveTo(pad, pad + i*cellSize);
      ctx.lineTo(pad + cells*cellSize, pad + i*cellSize);
    }
    ctx.strokeStyle = "#cbd5e1";
    ctx.lineWidth = 1;
    ctx.stroke();
  }

  function toPx(p){ return { x: pad + p.x*cellSize, y: pad + p.y*cellSize }; }

  function drawPolygon(ctx, pts, color, lineWidth=3){
    if (!pts || pts.length < 2) return;
    const a = toPx(pts[0]);
    ctx.beginPath();
    ctx.moveTo(a.x, a.y);
    for (let i=1; i<pts.length; i++){
      const b = toPx(pts[i]);
      ctx.lineTo(b.x, b.y);
    }
    ctx.closePath();
    ctx.strokeStyle = color;
    ctx.lineWidth = lineWidth;
    ctx.stroke();
  }

  function drawPoints(ctx, pts, color){
    ctx.fillStyle = color;
    pts.forEach(p => {
      const q = toPx(p);
      ctx.beginPath();
      ctx.arc(q.x, q.y, 3.5, 0, Math.PI*2);
      ctx.fill();
    });
  }

  // --------- génération de figures ---------
  // Les points sont en coordonnées de "cases" : 0..cells
  function genLevel1(){
    // triangle simple, bien dans la grille
    const x0 = randInt(3, 10), y0 = randInt(3, 10);
    const p0 = {x:x0, y:y0};
    const p1 = {x: clamp(x0 + randInt(2,4), 2, 12), y: clamp(y0 + randInt(-3,3), 2, 12)};
    const p2 = {x: clamp(x0 + randInt(-3,3), 2, 12), y: clamp(y0 + randInt(2,4), 2, 12)};
    return [p0,p1,p2];
  }

  function genLevel2(){
    // polygone 5-6 sommets (style “fiche”)
    const n = Math.random() < 0.5 ? 5 : 6;
    let x = randInt(4, 10), y = randInt(4, 10);
    const pts = [{x, y}];

    // déplacements entiers (cases) pour construire une forme non auto-croisée la plupart du temps
    const steps = [
      () => ({dx: randInt(2,4), dy: randInt(-2,2)}),
      () => ({dx: randInt(-1,2), dy: randInt(2,4)}),
      () => ({dx: randInt(-4,-2), dy: randInt(0,3)}),
      () => ({dx: randInt(-2,1), dy: randInt(-4,-2)}),
      () => ({dx: randInt(1,3), dy: randInt(-2,1)}),
      () => ({dx: randInt(-3,3), dy: randInt(-3,3)})
    ];

    for(let i=1;i<n;i++){
      const s = steps[i-1]();
      x = clamp(x + s.dx, 2, 12);
      y = clamp(y + s.dy, 2, 12);
      pts.push({x,y});
    }
    return pts;
  }

  function mirrorVertical(pts, axisX){
    // symétrie axiale par rapport à la droite x = axisX (en unités "cases")
    return pts.map(p => ({ x: 2*axisX - p.x, y: p.y }));
  }

  function genLevel3(){
    // on génère une figure (niveau2) et on demande de reproduire son image symétrique
    const base = genLevel2();
    const axisX = randInt(6,8); // axe vertical au milieu
    const img = mirrorVertical(base, axisX);
    return { base, axisX, img };
  }

  // --------- rendu d'un exercice ---------
  function makeCanvas(){
    const c = document.createElement("canvas");
    c.width = W; c.height = H;
    return c;
  }

  function renderExerciseCard(index, level){
    const card = document.createElement("article");
    card.className = "card";

    const title = document.createElement("h3");
    title.textContent = `Exercice ${index+1}`;
    card.appendChild(title);

    const pair = document.createElement("div");
    pair.className = "pair";
    card.appendChild(pair);

    const left = document.createElement("div");
    left.className = "canvasWrap";
    const right = document.createElement("div");
    right.className = "canvasWrap";

    const cModel = makeCanvas();
    const cBlank = makeCanvas();
    left.appendChild(cModel);
    right.appendChild(cBlank);

    pair.appendChild(left);
    pair.appendChild(right);

    const legend = document.createElement("div");
    legend.className = "legend";
    legend.innerHTML = `<span class="tag">Modèle</span><span class="tag">À reproduire</span>`;
    card.appendChild(legend);

    const ctxM = cModel.getContext("2d");
    const ctxB = cBlank.getContext("2d");

    drawGrid(ctxM); drawGrid(ctxB);

    let pts;
    let axisX = null;
    let prompt = "";

    if (level === 1){
      pts = genLevel1();
      prompt = "Reproduis la figure sur le quadrillage vide.";
      drawPolygon(ctxM, pts, "#0f172a", 3);
      drawPoints(ctxM, pts, "#0f172a");
    } else if (level === 2){
      pts = genLevel2();
      prompt = "Reproduis la figure sur le quadrillage vide (place d’abord les sommets).";
      drawPolygon(ctxM, pts, "#0f172a", 3);
      drawPoints(ctxM, pts, "#0f172a");
    } else {
      const o = genLevel3();
      pts = o.base;
      axisX = o.axisX;
      prompt = `Trace l’image de la figure par symétrie d’axe vertical x = ${axisX} (en cases).`;
      // modèle = figure + axe
      drawPolygon(ctxM, pts, "#0f172a", 3);
      drawPoints(ctxM, pts, "#0f172a");
      // axe
      ctxM.beginPath();
      const ax = pad + axisX*cellSize;
      ctxM.moveTo(ax, pad);
      ctxM.lineTo(ax, pad + cells*cellSize);
      ctxM.strokeStyle = "#94a3b8";
      ctxM.setLineDash([6,4]);
      ctxM.lineWidth = 2;
      ctxM.stroke();
      ctxM.setLineDash([]);

      // pour la correction, la bonne figure sera o.img
      card._solutionPts = o.img;
      card._axisX = axisX;
    }

    const p = document.createElement("p");
    p.className = "note";
    p.style.margin = "10px 0 0";
    p.style.color = "#334155";
    p.textContent = prompt;
    card.appendChild(p);

    // stock solution (niveau 1/2 = même pts ; niveau 3 = image)
    if (!card._solutionPts) card._solutionPts = pts;

    // pour correction : on dessine sur le quadrillage de droite en rouge, mais caché/montré via classe
    card._blankCanvas = cBlank;

    return card;
  }

  function renderCorrectionCard(exCard, index){
    const card = document.createElement("article");
    card.className = "card";

    const title = document.createElement("h3");
    title.textContent = `Correction ${index+1}`;
    card.appendChild(title);

    const pair = document.createElement("div");
    pair.className = "pair";
    card.appendChild(pair);

    const left = document.createElement("div");
    left.className = "canvasWrap";
    const right = document.createElement("div");
    right.className = "canvasWrap";

    const cModel = exCard.querySelector("canvas"); // modèle du card exercice
    const cloneModel = makeCanvas();
    cloneModel.getContext("2d").drawImage(cModel, 0, 0);

    const cCorr = makeCanvas();

    left.appendChild(cloneModel);
    right.appendChild(cCorr);

    pair.appendChild(left);
    pair.appendChild(right);

    const legend = document.createElement("div");
    legend.className = "legend";
    legend.innerHTML = `<span class="tag">Modèle</span><span class="tag">Correction</span>`;
    card.appendChild(legend);

    const ctxC = cCorr.getContext("2d");
    drawGrid(ctxC);

    // correction = figure rouge
    drawPolygon(ctxC, exCard._solutionPts, "#b91c1c", 3);
    drawPoints(ctxC, exCard._solutionPts, "#b91c1c");

    // si niveau 3, redessiner l’axe sur correction aussi
    if (exCard._axisX != null){
      const ax = pad + exCard._axisX*cellSize;
      ctxC.beginPath();
      ctxC.moveTo(ax, pad);
      ctxC.lineTo(ax, pad + cells*cellSize);
      ctxC.strokeStyle = "#94a3b8";
      ctxC.setLineDash([6,4]);
      ctxC.lineWidth = 2;
      ctxC.stroke();
      ctxC.setLineDash([]);
    }

    return card;
  }

  // --------- orchestration ----------
  const exContainer = document.getElementById("exercises");
  const corrContainer = document.getElementById("corrections");
  const btnNew = document.getElementById("btnNew");
  const btnCorr = document.getElementById("btnCorr");
  const btnPrint = document.getElementById("btnPrint");
  const selLevel = document.getElementById("level");
  const selCount = document.getElementById("count");

  let showCorrectionsOnScreen = false;
  let currentCards = [];

  function generate(){
    exContainer.innerHTML = "";
    corrContainer.innerHTML = "";
    currentCards = [];

    const level = parseInt(selLevel.value, 10);
    const count = parseInt(selCount.value, 10);

    for (let i=0; i<count; i++){
      const card = renderExerciseCard(i, level);
      currentCards.push(card);
      exContainer.appendChild(card);
    }

    // construire la section correction (utile pour impression)
    currentCards.forEach((c, i) => {
      corrContainer.appendChild(renderCorrectionCard(c, i));
    });

    // Sur écran, on peut masquer la section correction en bas si on veut
    corrContainer.classList.toggle("hidden", !showCorrectionsOnScreen);
  }

  function toggleCorrections(){
    showCorrectionsOnScreen = !showCorrectionsOnScreen;
    corrContainer.classList.toggle("hidden", !showCorrectionsOnScreen);
  }

  function printPDF(){
    // Le navigateur -> “Enregistrer en PDF”
    window.print();
  }

  btnNew.addEventListener("click", generate);
  btnCorr.addEventListener("click", toggleCorrections);
  btnPrint.addEventListener("click", printPDF);

  generate();
</script>
</body>
</html>
